#!/usr/bin/env python3
"""
Unit and regression test for the tga_proj package.
"""

# Import package, test suite, and other packages as needed
import sys
import unittest
from contextlib import contextmanager
from io import StringIO
import logging
import numpy as np
import os
import errno
from tga_proj import main, data_analysis

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
DISABLE_REMOVE = logger.isEnabledFor(logging.DEBUG)

CURRENT_DIR = os.path.dirname(__file__)
MAIN_DIR = os.path.join(CURRENT_DIR, '..')
TEST_DATA_DIR = os.path.join(CURRENT_DIR, 'rawdata_proc')
PROJ_DIR = os.path.join(MAIN_DIR, 'tga_proj')
DATA_DIR = os.path.join(PROJ_DIR, 'data')
DATA_FILE_LOC = os.path.join(DATA_DIR, 'data.csv')

# Assumes running tests from the main directory
DEF_CSV_OUT = os.path.join(MAIN_DIR, 'data_analysis.csv')
DEF_PNG_OUT = os.path.join(MAIN_DIR, 'data_analysis.png')

def silent_remove(filename, disable=False):
    """
    when not in debug mode (disable is false), files will be removed
    Removes the target file name, catching and ignoring errors that indicate that the
    file does not exist.
    @param filename: The file to remove.
    @param disable: boolean to flag if want to disable removal
    raise means stop and identify the error
    """
    if not disable:
        try:
            os.remove(filename)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

class TestMain(unittest.TestCase):
    # These tests make sure that the program can run properly from main
    def testData(self):
        # Checks that runs with defaults and that files are created
        test_input = ["-c", DATA_FILE_LOC]
        try:
            if logger.isEnabledFor(logging.DEBUG):
                main(test_input)
            # checks that the expected message is sent to standard out
            with capture_stdout(main, test_input) as output:
                self.assertTrue("data_analysis.csv" in output)

            self.assertTrue(os.path.isfile("data_analysis.csv"))
            self.assertTrue(os.path.isfile("data_analysis.png"))
        finally:
            silent_remove(DEF_CSV_OUT, disable=DISABLE_REMOVE)
            silent_remove(DEF_PNG_OUT, disable=DISABLE_REMOVE)

class TestMainFailWell(unittest.TestCase):
    def testMissingFile(self):
        test_input = ["-c", "pleaseletthistestpass.txt"]
        if logger.isEnabledFor(logging.DEBUG):
            main(test_input)
        with capture_stderr(main, test_input) as output:
            self.assertTrue("pleaseletthistestpass.txt" in output)

class TestDataAnalysis(unittest.TestCase):
    def testData(self):
        # Tests that the np array generated by the data_analysis function matches saved expected results
        csv_data = np.loadtxt(fname=DATA_FILE_LOC, delimiter=',')
        analysis_results = data_analysis(csv_data)
        expected_results = np.loadtxt(fname=os.path.join(TEST_DATA_DIR, "data_results.csv"), delimiter=',')
        self.assertTrue((expected_results == analysis_results).all())

# Utility functions

# From http://schinckel.net/2013/04/15/capture-and-test-sys.stdout-sys.stderr-in-unittest.testcase/
@contextmanager
def capture_stdout(command, *args, **kwargs):
    # pycharm doesn't know six very well, so ignore the false warning
    # noinspection PyCallingNonCallable
    out, sys.stdout = sys.stdout, StringIO()
    command(*args, **kwargs)
    sys.stdout.seek(0)
    yield sys.stdout.read()
    sys.stdout = out


@contextmanager
def capture_stderr(command, *args, **kwargs):
    # pycharm doesn't know six very well, so ignore the false warning
    # noinspection PyCallingNonCallable
    err, sys.stderr = sys.stderr, StringIO()
    command(*args, **kwargs)
    sys.stderr.seek(0)
    yield sys.stderr.read()
    sys.stderr = err
